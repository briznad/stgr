// Generated by CoffeeScript 1.8.0
(function() {
  var GitHub, SSH, activeMilestones, app, checkDiff, compareResults, express, fetchMilestones, file, github, githubAuth, githubRepo, init, initQuery, initRoutes, initServer, pinnacle, queryBranch, queryGithub, queryInterval, queryLabels, queryMilestone, queryPull, queryServer, queryServers, recentlyChanged, routeHandlers, routes, serverData, serverList, serverListCount, serverResults, settings, _;

  console.log('\nstgr API server is warming up...\n');


  /*
  load required modules
   */

  file = require('fs');

  _ = require('underscore');

  SSH = require('ssh2');

  express = require('express');

  GitHub = require('octonode');

  githubAuth = require('./github_credentials');


  /*
  load global vars
   */

  settings = {
    devMode: true,
    httpPort: 7847
  };

  app = express();

  github = GitHub.client({
    username: githubAuth.username,
    password: githubAuth.password
  });

  githubRepo = 'Thrillist/Pinnacle';

  pinnacle = github.repo(githubRepo);

  queryInterval = 10;

  recentlyChanged = false;

  activeMilestones = {};

  serverResults = {};

  serverData = {};

  serverListCount = 0;

  serverList = ['yolo.thrillist.com', 'mojo.thrillist.com', 'stage-coach.thrillist.com', 'beta.thrillist.com', 'beta.thrillistmediagroup.com', 'beta.supercompressor.com', 'duper.supercompressor.com'];


  /*
  init
   */

  init = function() {
    app.use(express.bodyParser());
    app.use(express.cookieParser());
    initServer();
    return initQuery();
  };


  /*
  init server
   */

  initServer = function() {
    app.listen(settings.httpPort);
    console.info('\nserver started at http://127.0.0.1:' + settings.httpPort);
    if (!settings.devMode) {
      console.info('\nPROD: errors will be caught and logged');
      process.on('uncaughtException', function(err) {
        return console.log('\nCaught the following exception:\n' + err);
      });
    } else {
      console.info('\nDEV: errors will NOT be caught');
    }
    initRoutes();
    return console.log('\n\n                  ####################\n                   s t g r  -  A P I\n                  ####################\n');
  };


  /*
  load routes
   */

  routes = {
    'get': {
      '/': 'root',
      '/test': 'test',
      '/list': 'list',
      '/detailedList': 'detailedList'
    }
  };


  /*
  init routes
   */

  initRoutes = function() {
    return _.each(routes, function(value, key) {
      var verb;
      verb = key;
      return _.each(value, function(value, key) {
        return app[verb](key, routeHandlers[value]);
      });
    });
  };


  /*
  register route handlers
   */

  routeHandlers = {
    root: function(req, res) {
      console.log('\nOMG, a request!');
      console.info('request made for:\n' + req.url);
      return res.json({
        stgrSays: 'Hello World!'
      });
    },
    test: function(req, res) {
      console.log('\nOMG, a request!');
      console.info('request made for:\n' + req.url);
      res.header('Access-Control-Allow-Origin', '*');
      return res.json({
        stgrSays: 'serving test!'
      });
    },
    recentlyChanged: function(req, res) {
      console.log('\nOMG, a request!');
      console.info('request made for:\n' + req.url);
      res.header('Access-Control-Allow-Origin', '*');
      return res.json({
        recentlyChanged: recentlyChanged
      });
    },
    list: function(req, res) {
      console.log('\nOMG, a request!');
      console.info('request made for:\n' + req.url);
      res.header('Access-Control-Allow-Origin', '*');
      return res.json({
        recentlyChanged: recentlyChanged,
        data: serverResults
      });
    },
    detailedList: function(req, res) {
      console.log('\nOMG, a request!');
      console.info('request made for:\n' + req.url);
      res.header('Access-Control-Allow-Origin', '*');
      return res.json({
        recentlyChanged: recentlyChanged,
        data: serverData
      });
    }
  };


  /*
  init query
   */

  initQuery = function() {
    var t;
    t = setInterval(function() {
      return queryServers();
    }, 1000 * 60 * queryInterval);
    serverListCount = serverList.length;
    return queryServers();
  };

  queryServers = function() {
    var newResults;
    console.log('\nquerying staging servers');
    newResults = {};
    return _.each(serverList, function(server) {
      return queryServer(newResults, server, function() {
        if (serverListCount === _.keys(newResults).length) {
          console.log('\n');
          console.log(newResults);
          return compareResults(newResults);
        }
      });
    });
  };

  queryServer = function(newResults, server, callback) {
    var conn;
    conn = new SSH();
    conn.on('ready', function() {
      return conn.shell('echo "test"', function(err, stream) {
        var output;
        if (err) {
          throw err;
        }
        output = [];
        stream.on('close', function() {
          var currentBranch;
          conn.end();
          currentBranch = output.pop();
          newResults[server] = currentBranch;
          return callback();
        });
        stream.on('data', function(data) {
          data = data.toString('utf8').replace(/\s/g, '');
          if (data.length < 2 || /^\[/.test(data)) {
            return false;
          }
          if (/\[/.test(data)) {
            data = data.split(/\[/)[0];
          }
          return output.push(data);
        });
        stream.stderr.on('data', function(data) {
          return console.error('STDERR: ' + data);
        });
        return stream.end('cd $(cat /etc/httpd/conf.d/pinnacle.conf | grep -m 1 DocumentRoot | sed s/DocumentRoot// | sed s/\\"//g)\ngit rev-parse --abbrev-ref HEAD\nexit\n');
      });
    });
    return conn.connect({
      host: server,
      port: 22,
      username: 'ec2-user',
      privateKey: file.readFileSync('/Users/bradmallow/Documents/keys/dops-dev.pem')
    });
  };

  compareResults = function(newResults) {
    var lastResults;
    console.log('\ncomparing results');
    if (_.isEqual(serverResults, newResults)) {
      console.log('\nno change');
      recentlyChanged = false;
    } else {
      console.log('\nnew branches!');
      recentlyChanged = true;
      lastResults = serverResults;
      serverResults = newResults;
      newResults = {};
      fetchMilestones(function() {
        return checkDiff(lastResults, serverResults);
      });
    }
    return console.log('\nchecking again in ' + queryInterval + ' minute/s');
  };

  fetchMilestones = function(callback) {
    if (callback == null) {
      callback = function() {};
    }
    return pinnacle.milestones({
      page: 1,
      per_page: 100,
      state: 'all',
      sort: 'completeness'
    }, function(err, data, headers) {
      if (data) {
        _.each(data, function(milestone) {
          if (_.invert(serverResults)[milestone.title]) {
            return activeMilestones[milestone.title] = milestone.number;
          }
        });
      } else {
        console.log('\n');
        console.error('error retrieving list of milestones');
      }
      return callback();
    });
  };

  checkDiff = function(lastResults, serverResults) {
    var changeCount, newServerData;
    newServerData = {};
    changeCount = 0;
    return _.each(serverResults, function(branch, server) {
      if (lastResults[server] !== branch) {
        changeCount++;
        return queryGithub(newServerData, server, branch, function() {
          var t;
          if (changeCount === _.keys(newServerData).length) {
            serverData = _.extend(serverData, newServerData);
            console.log('\nGithub querying complete!');
            activeMilestones = {};
            newServerData = {};
            console.log('\n');
            console.log(serverData);
            return t = setTimeout(function() {
              console.log('\n');
              return console.log(serverData);
            }, 1);
          }
        });
      }
    });
  };

  queryGithub = function(newServerData, server, branch, callback) {
    var callbackCheck, complete;
    if (callback == null) {
      callback = function() {};
    }
    complete = {
      branch: false,
      pull: false,
      labels: false,
      milestone: false
    };
    callbackCheck = function(type) {
      complete[type] = true;
      if (complete.branch && complete.pull && complete.labels && complete.milestone) {
        return callback();
      }
    };
    newServerData[server] = {
      server: server,
      property: server.split('.')[1],
      branch: {
        name: branch
      }
    };
    queryBranch(newServerData, server, branch, function() {
      return callbackCheck('branch');
    });
    queryPull(newServerData, server, branch, function() {
      callbackCheck('pull');
      if (newServerData[server].pull.number) {
        return queryLabels(newServerData, server, newServerData[server].pull.number, function() {
          return callbackCheck('labels');
        });
      } else {
        return callbackCheck('labels');
      }
    });
    return queryMilestone(newServerData, server, branch, function() {
      return callbackCheck('milestone');
    });
  };

  queryBranch = function(newServerData, server, branch, callback) {
    if (callback == null) {
      callback = function() {};
    }
    return pinnacle.branch(branch, function(err, data, headers) {
      if (err) {
        if (err.statusCode === 404) {
          newServerData[server].branch = _.extend(newServerData[server].branch || {}, {
            name: branch,
            open: false
          });
        }
      } else {
        newServerData[server].branch = _.extend(newServerData[server].branch || {}, {
          name: data.name,
          link: data._links.html,
          open: true
        });
        newServerData[server].last_commit = _.extend(newServerData[server].last_commit || {}, {
          date: data.commit.commit.author.date,
          message: data.commit.commit.message
        });
        newServerData[server].author = _.extend(newServerData[server].author || {}, {
          name: data.commit.author.login,
          link: data.commit.author.html_url,
          pic: data.commit.author.avatar_url
        });
      }
      return callback();
    });
  };

  queryPull = function(newServerData, server, branch, callback) {
    if (callback == null) {
      callback = function() {};
    }
    return pinnacle.prs({
      page: 1,
      per_page: 100,
      head: 'Thrillist:' + branch,
      state: 'all'
    }, function(err, data, headers) {
      if (data && data.length) {
        data = data[0];
        newServerData[server].branch = _.extend(newServerData[server].branch || {}, {
          name: data.head.ref,
          link: 'https://github.com/Thrillist/Pinnacle/tree/' + data.head.ref
        });
        newServerData[server].pull = _.extend(newServerData[server].pull || {}, {
          open: data.state === 'open' ? true : false,
          merged: data.merged_at ? true : false,
          name: data.title,
          link: data._links.html.href
        });
        newServerData[server].author = _.extend(newServerData[server].author || {}, {
          name: data[data.assignee ? 'assignee' : 'user'].login,
          link: data[data.assignee ? 'assignee' : 'user'].html_url,
          pic: data[data.assignee ? 'assignee' : 'user'].avatar_url
        });
      } else {
        newServerData[server].pull = false;
      }
      return callback();
    });
  };

  queryLabels = function(newServerData, server, number, callback) {
    var issue;
    if (callback == null) {
      callback = function() {};
    }
    issue = github.issue(githubRepo, number);
    return issue.info(function(err, data, headers) {
      if (err) {
        console.error(err);
        newServerData[server].pull.labels = false;
      } else if (data) {
        newServerData[server].pull.labels = [];
        _.each(data.labels, function(label) {
          return newServerData[server].pull.labels.push({
            link: label.url.replace('api.github.com/repos', 'github.com').replace('+', '%20'),
            color: '#' + label.color,
            name: label.name
          });
        });
      }
      return callback();
    });
  };

  queryMilestone = function(newServerData, server, branch, callback) {
    if (callback == null) {
      callback = function() {};
    }
    if (activeMilestones[branch]) {
      return pinnacle.issues({
        page: 1,
        per_page: 100,
        milestone: activeMilestones[branch],
        state: 'all'
      }, function(err, data, headers) {
        if (data) {

        } else {
          newServerData[server].milestone = false;
        }
        return callback();
      });
    } else {
      newServerData[server].milestone = false;
      return callback();
    }
  };

  init();

}).call(this);
